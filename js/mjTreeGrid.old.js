$(document).ready(function () {

    // node data structure:

    // {id: int, mandatory. If omitted one will be generated
    // pid: parent key field, default null
    // image: string (default null)
    // selected: true,false (ignored if show_checkbox is true, default false)
    // expanded: true|false
    // checked: 0|1|2, 0 is not checked, 1 is checked, 2 is half ticked (ignored if show_checkbox is false)
    // disabled: true or false (default false)
    // data: null user defined data

    // TBD:
    // virtual rendering
    // filter not working in conjuction with drag and drop,  if we drag drop, filter then clear the filter the order is not preserved
    // return level property in toArray, getItem, etc
    // themes
    // width, height
    // disabled
    // _enableKeyEvents
    // wrap_text

    // data only: toArrayDataOnly, addRootNode
    // element only: getRow
    // element and data: toArray, getItem, getChildren, getSiblings, getSelected, getChecked, getExpanded  

    (function ($) {

        var mjTreeGrid = {

            init: function (options, el) {

                this.widget_class = "mjTreeGrid";

                this._validateData(options);

                this.el = el;
                this.$el = $(el);

                // plugin have been applied previously
                // blow away any existing instance

                this.close();

                this._render();

                this._startListening();
            },

            //----------------------------------------------------------------------------------------------------------
            // private functions

            _validateItem: function (o) {

                var default_item = {
                    image: null,
                    selected: null,
                    checked: null,
                    disabled: false,
                    expanded: false
                };

                var x = $.extend({}, default_item, o);  // o overrides default

                $.extend(o, x);

                // every node must have an id

                if ( mjcore.isEmpty(o[this.idf]) )
                    o[this.idf] = mjcore.generateId();

                if (mjcore.isEmpty(o[this.pidf]))
                    o[this.pidf] = null;

                // valid values of selected is true,false
                // checked and selected are mutually exclusive

                if (this.settings.show_checkboxes) {

                    // valid values for checked is 0,1,2

                    switch (String(o.checked)) {
                        case "false": o.checked = 0; break;
                        case "true": o.checked = 1; break;
                        case "0": o.checked = 1; break;
                        case "1": o.checked = 0; break;
                        case "2": o.checked = 2; break;

                        default:
                            o.checked = 0;
                            break;
                    }

                    o.selected = null;
                }
                else {

                    switch (String(o.selected)) {

                        case "0": o.selected = false; break;
                        case "1": o.selected = true; break;
                        case "true": o.selected = true; break;
                        case "false": o.selected = false; break;

                        default:
                            o.selected = false;
                    }

                    o.checked = null;
                }

                switch (String(o.disabled)) {

                    case "0": o.disabled = false; break;
                    case "1": o.disabled = true; break;
                    case "true": o.disabled = true; break;
                    case "false": o.disabled = false; break;

                    default:
                        o.disabled = false;
                }
            },

            _validateData: function (options) {

                var default_settings = {
                    items: [],
                    show_checkboxes: false,     // checkbox, text, null (if a cellRender is defined the text is generated by that function)
                    cellRender: null,           // custom rendering function each each item. signature: cellRender(item)

                    animation_duration: 0,      // time in milliseconds, 0 for no animation 
                    multi_select: false,        // 
                    dragdrop: false,
                    sublist_indent: 16,         // sublist indent
                    recursive: true,

                    id_field: "id",             // mandatory, name of the id field in every items object
                    parent_id_field: "pid",     // mandatory, name of the parent id field in every object

                    columns: [],                // array of column names for fields present in items
                    wrap_text: false,
                    show_borders: true,
                    border_color: "efefef",

                    // properties common to all controls

                    width: '100%',
                    height: '100%',
                    disabled: false,
                    theme: null
                };

                this.settings = $.extend({}, default_settings, options);    // options overrides default        

                var self = this;
                var s = this.settings;

                var items = s.items;

                if (!items)
                    return;

                // make some short cuts

                if ( mjcore.isEmpty(s.id_field) )
                    mjcore.mjError("mjTreeGrid Error: id_field not defined!!");

                if ( mjcore.isEmpty(s.parent_id_field))
                    mjcore.mjError("mjTreeGrid Error: parent_id field not defined!!");

                this.idf = s.id_field;
                this.pidf = s.parent_id_field;

                var map = {};

                $.each(items, function (index, o) {

                    self._validateItem(o);

                    var id = o[self.idf];

                    if (map[id])                    
                        mjcore.mjError("mjTreeGrid Error: duplicate id: " + id + " found in data. Ids must be unique.");

                    map[id] = id;

                    // look for references to non existant parents
                    // if they exist set the parent id field to null

                    var pid = o[self.pidf];

                    if (pid != null)
                    {
                        var len = items.length;

                        for (var i = 0; i < len; i++) {

                            var x = items[i];

                            if (x[self.idf] == pid)      // found the parent
                                break;
                        }

                        if (i == len)               // parent not found, set parent id field to null making them top level nodes
                            o[self.pidf] = null;
                    }
                });

                // we do not assume the items are any particular order
                // child nodes could appear before parent nodes
                // however before we can render wee need child nodes to appear directly after the parent node
                // to do this convert to a tree and flatten the tree

                var tree = this.toTree(items);
                s.items = this.flattenTree(tree);
            },

            _startListening: function () {

                var self = this;

                // we may be recreating the plugin for the second time
                // if we do not stop listening to events on the element we get strange behaviour

                this._stopListening();

                this.$el.on("click", ".mj-expander", function (e) {

                    e.preventDefault();
                    e.stopPropagation();

                    // clicked on the expander

                    // expand/collapse	

                    var q = $(e.currentTarget);

                    var p = q.closest(".mj-row");
                    var o = p.data("d");

                    if (q.hasClass("mj-open")) {

                        // collapse

                        self.collapse(o[self.idf]);
                        self.$el.trigger("collapse", o);
                    }
                    else {

                        // expand

                        self.expand(o[self.idf]);
                        self.$el.trigger("expand", o);
                    }
                });

                this.$el.on("click", ".mj-treegrid", function (e) { self.$el.trigger("emptySpaceClick");  });   // click in non-data part of grid

                this.$el.find("click", ".mj-content").unbind('click');

                this.$el.on("click", ".mj-content", function (e) {

                    // clicked on the checkbox or text

                    e.preventDefault();
                    e.stopPropagation();

                    var q = $(e.currentTarget);
                    var p = q.closest(".mj-row");
                    var o = p.data("d");

                    if (o) {

                        if (o.disabled)
                            return;

                        if (self.settings.show_checkboxes) {

                            if (o.checked == 1) {
                                self.uncheck(o[self.idf]);
                                self.$el.trigger("checkChange", o);
                            }
                            else {
                                self.check(o[self.idf]);
                                self.$el.trigger("checkChange", o);
                            }
                        }
                        else {                           

                            // we never deselect

                            //if (o.selected) {

                            //    self.deselect(o[self.idf]);
                            //    self.$el.trigger("selected", o);
                            //}
                            //else {

                                self.select(o[self.idf]);
                                self.$el.trigger("selected", o);
                            //}
                        }
                    }
                    else {

                        mjcore.mjError("mjTreeGrid: node click: node " + id + " not found");
                    }
                });

                if (this.settings.dragdrop) {

                    jQuery.event.props.push('dataTransfer');

                    //this.$el.on("dragstart", ".mj-row", function (e) { mjcore.isEmpty("dragstart"); });

                    this.$el.on({

                        dragstart: function (e) {


                        },
                        dragenter: function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        },
                        dragleave: function (e) {
                            e.preventDefault();
                            e.stopPropagation(); 
                        },
                        dragover: function (e) {
                            e.preventDefault();
                            e.stopPropagation(); 
                        },
                        dragend: function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                        },
                        drop: function (e) {

                            e.preventDefault();
                            e.stopPropagation();

                            var id = self.drop_id;
                            //var id = e.dataTransfer.getData("dragdrop-data");     // problem on IE

                            var k = self.getItem(id);
                            var x = k.element;

                            var drag_target = $(x).data("d");

                            var arr = self.toArray();

                            if (arr.length < 2)
                                return;

                            var o = arr[arr.length - 1];

                            self.drop_placement = "drop-after";

                            var children = self.getChildren(id);

                            if (self.settings.beforeDrop) {
                                if (self.settings.beforeDrop(drag_target, o.data, self.drop_placement)) {

                                    // beforeDrop gives the user a chance to cancel the dragdrop

                                    $(o.element).after(x);

                                    // move the children

                                    var q = $(o.element).next();

                                    for (i = 0; i < children.length; i++) {
                                        q = q.after(children[i].element);
                                        q = q.next();

                                        //q = $(e.currentTarget).next().next().before(children[i].element);
                                    }

                                    drag_target[self.pidf] = null;        // update the parent id      

                                    if (self.settings.afterDrop)
                                        self.settings.afterDrop(drag_target, o.data);

                                    self._applyCSS();
                                }
                            }
                            else {
                                // there is no beforeDrop function, just do it
                                // beforeDrop gives the user a chance to cancel the dragdrop

                                $(o.element).after(x);

                                // move the children

                                var q = $(o.element).next();

                                for (i = 0; i < children.length; i++) {
                                    q = q.after(children[i].element);
                                    q = q.next();

                                    //q = $(e.currentTarget).next().next().before(children[i].element);
                                }

                                drag_target[self.pidf] = null;        // update the parent id   

                                if (self.settings.afterDrop)
                                    self.settings.afterDrop(drag_target, o.data);

                                self._applyCSS();
                            }
                        },
                    }, '.mj-treegrid');

                    this.$el.on({

                        dragstart: function (e) {

                            $(this).css('opacity', '0.5');

                            var id = $(e.currentTarget).data("d").id;

                            self.drop_id = id;

                            var browser = mjcore.getBrowserName();

                            if (browser != "msie") {
                                e.dataTransfer.setData("dragdrop-data", id);          // problem in IE

                                //e.originalEvent.dataTransfer.setData('text/plain', 'anything');
                            }
                        },

                        dragenter: function (e) {

                            e.preventDefault();

                            e.preventDefault();
                            e.stopPropagation();
                        },

                        dragleave: function (e) {

                            e.preventDefault();
                            e.stopPropagation();

                            //var o = $(e.currentTarget).data("d");
                            //$(e.currentTarget).find(".mj-cell").first().css("background", "#f00");
                            //console.log("dragleave: id = %d", o.id);
                        },

                        dragover: function (e) {

                            e.preventDefault();
                            e.stopPropagation();

                            //var id = e.dataTransfer.getData("dragdrop-data");     // cant get dataTransfer data in dragover

                            var o = self.getItem(self.drop_id);

                            var draggable = $(o.element);
                            var droppable = $(e.currentTarget);

                            self.$el.find(".mj-cell").removeClass('mj-drag-over');
                            self.$el.find(".mj-cell .mj-content").removeClass('mj-drag-over-dashed-border-above');
                            self.$el.find(".mj-cell .mj-content").removeClass('mj-drag-over-dashed-border-below');

                            $(e.currentTarget).find(".mj-cell").addClass('mj-drag-over');
                          
                            if (self.drop_id == $(e.currentTarget).data("d").id)
                                return;

                            //mjcore.isEmpty(e.originalEvent);

                            var h = droppable.outerHeight();

                            var a = parseInt(e.originalEvent.clientY, 10) - parseInt(self.$el.offset().top, 10);
                            var b = droppable.offset().top - parseInt(self.$el.offset().top, 10);

                            //mjcore.isEmpty("a = " + a + " b = " + b);

                            self.drop_placement = "drop-into";

                            if (a <= b + h / 4) {

                                //mjcore.isEmpty("above");
                                $(e.currentTarget).find(".mj-cell .mj-content").addClass('mj-drag-over-dashed-border-above');

                                self.drop_placement = "drop-before";
                            }
                            else if (a > b + h - h / 4) {
                                //mjcore.isEmpty("below");
                                $(e.currentTarget).find(".mj-cell .mj-content").addClass('mj-drag-over-dashed-border-below');

                                self.drop_placement = "drop-after";
                            }
                            else {
                                //mjcore.isEmpty("into");
                            }
                        },

                        dragend: function (e) {

                            e.preventDefault();
                            e.stopPropagation();

                            self.$el.find(".mj-row .mj-cell").removeClass('mj-drag-over');
                            self.$el.find(".mj-row .mj-cell .mj-content").removeClass('mj-drag-over-dashed-border-above');
                            self.$el.find(".mj-row .mj-cell .mj-content").removeClass('mj-drag-over-dashed-border-below');

                            $(this).css('opacity', '1');

                            //var browser = mjcore.getBrowserName();

                            //mjcore.isEmpty("dragend: browser = " + browser);

                            //if (browser == "safari") {

                            //    // jquery.drop does not fire on safari

                            //    var id = self.drop_id;

                            //    var x = self.getRow(id);

                            //    var drag_target = $(x).data("d");
                            //    var drop_target = $(e.originalEvent.target.offsetParent).data("d");

                            //    //mjcore.isEmpty(drag_target);
                            //    //mjcore.isEmpty(drop_target);
                            //    mjcore.isEmpty(e);

                            //    if (self.settings.beforeDrop) {
                            //        if (self.settings.beforeDrop(drag_target, drop_target, self.drop_placement)) {

                            //            // beforeDrop gives the user a chance to cancel the dragdrop

                            //            self._dropIt(e);
                            //        }
                            //    }
                            //    else {
                            //        // there is no beforeDrop function, just do it

                            //        self._dropIt(e);
                            //    }

                            //    if (self.settings.afterDrop)
                            //        self.settings.afterDrop(drag_target, drop_target);
                            //}
                        },

                        drop: function (e) {

                            e.preventDefault();
                            e.stopPropagation();

                            var id = self.drop_id;
                            //var id = e.dataTransfer.getData("dragdrop-data");     // problem on IE

                            //mjcore.isEmpty("drop: id = " + id);

                            var o = self.getItem(id);

                            var drag_target = o.data;
                            var drop_target = $(e.currentTarget).data("d");

                            if (self.settings.beforeDrop) {
                                if (self.settings.beforeDrop(drag_target, drop_target, self.drop_placement)) {

                                    // beforeDrop gives the user a chance to cancel the dragdrop

                                    self._dropIt(e);

                                    if (self.settings.afterDrop)
                                        self.settings.afterDrop(drag_target, drop_target, self.drop_placement);
                                }
                            }
                            else {
                                // there is no beforeDrop function, just do it

                                self._dropIt(e);

                                if (self.settings.afterDrop)
                                    self.settings.afterDrop(drag_target, drop_target, self.drop_placement);
                            }


                        },
                    }, '.mj-row');
                }
            },

            _dropIt: function(e)
            {
                switch (this.drop_placement) {
                    case "drop-before": this._dropBefore(e); break;
                    case "drop-after": this._dropAfter(e); break;
                    default: this._dropInto(e); break;
                }
            },

            _isBadDrag: function (children, drag_target, drop_target)
            {
                // cant drag a parent into one of its children

                for (var i = 0, len = children.length; i < len; i++) {

                    var c = children[i].data;

                    if (c.id == drop_target.id)
                        return true;
                }

                // cant drag into itself

                if (drop_target == drag_target)
                    return true;

                return false;
            },            

            _dropBefore: function (e) {

                var self = this;

                var id = self.drop_id;
                //var id = e.dataTransfer.getData("dragdrop-data");     // problem on IE

                var o = self.getItem(id);

                var children = self.getChildren(id);

                //var drag_target = x.data("d");
                var drag_target = o.data;
                var drop_target = $(e.currentTarget).data("d");

                if (this._isBadDrag(children, drag_target, drop_target))
                    return;

                // update the parent id

                drag_target[self.pidf] = drop_target[self.pidf];



                // do the same to the original item

                var index = this._findOriginalItemIndex(drag_target[this.idf]);

                if (index > -1) {
                    var q = this.original_items[index];
                    q[this.pidf] = drop_target[this.pidf];

                    // TBD: order not preserved
                }


                $(e.currentTarget).before(o.element);

                // move the children

                for (i = 0; i < children.length; i++)
                    $(e.currentTarget).before(children[i].element);

                self._applyCSS();
            },

            _dropAfter: function (e) {

                var self = this;

                var id = self.drop_id;
                //var id = e.dataTransfer.getData("dragdrop-data");         // problem on IE

                var x = this.getItem(id);
               
                var children = this.getChildren(id);

                var drag_target = x.data;
                var drop_target = $(e.currentTarget).data("d");                

                if (this._isBadDrag(children, drag_target, drop_target))
                    return;

                var items = this.toArrayDataOnly();

                if (this.hasChildren(drop_target, items)) {

                    // we are dropping an item after a folder

                    // find the drop target in the array

                    var arr = this.toArray();

                    for (var i = 0; i < arr.length; i++) {

                        var o = arr[i];

                        if (o.data[this.idf] == drop_target[this.idf])
                            break;
                    }

                    var level = this.getLevel(drop_target, arr);

                    //mjcore.isEmpty("hasChildren: index of drop target = " + i + " level of drop_target = " + level);

                    if (i >= arr.length) {

                        // drop after last element in the list

                        $(o.element).after(x.element);

                        // move the children

                        var q = $(o.element).next();

                        for (i = 0; i < children.length; i++) {
                            q = q.after(children[i].element);
                            q = q.next();

                            //q = $(e.currentTarget).next().next().before(children[i].element);
                        }
                    }
                    else {

                        // find the next node with a level less than or equal to the drop_target

                        for (i++; i < arr.length; i++) {
                            var o = arr[i];

                            if (this.getLevel(o.data, arr) <= level)
                                break;
                        }

                        if (i < arr.length - 1) {

                            $(o.element).before(x.element);

                            // move the children

                            for (i = 0; i < children.length; i++)
                                $(o.element).before(children[i].element);
                        }
                        else
                        {
                            // drop after last element in the list

                            $(o.element).after(x.element);

                            // move the children

                            var q = $(o.element).next();

                            for (i = 0; i < children.length; i++) {
                                q = q.after(children[i].element);
                                q = q.next();

                                // TBD: order not preserved
                            }
                        }
                    }

                    drag_target[this.pidf] = drop_target[this.pidf];        // update the parent id

                    // do the same to the original item

                    var index = this._findOriginalItemIndex(drag_target[this.idf]);

                    if (index > -1) {
                        var q = this.original_items[index];
                        q[this.pidf] = drop_target[this.pidf];
                    }
                }
                else {

                    $(e.currentTarget).after(x.element);

                    // move the children

                    var q = $(e.currentTarget).next();

                    for (i = 0; i < children.length; i++) {
                        q = q.after(children[i].element);
                        q = q.next();

                        //q = $(e.currentTarget).next().next().before(children[i].element);
                    }

                    drag_target[this.pidf] = drop_target[this.pidf];        // update the parent id

                    // do the same to the original item

                    var index = this._findOriginalItemIndex(drag_target[this.idf]);

                    if (index > -1) {
                        var q = this.original_items[index];
                        q[this.pidf] = drop_target[this.pidf];
                    }
                }

                this._applyCSS();
            },

            _dropInto: function (e) {

                var self = this;

                var id = self.drop_id;
                //var id = e.dataTransfer.getData("dragdrop-data"); // problem on IE

                //mjcore.isEmpty("_dropInto: id = " + id);

                var x = this.getItem(id);        // row we are moving

                var children = this.getChildren(id);

                var drag_target = x.data;
                var drop_target = $(e.currentTarget).data("d");               

                if (this._isBadDrag(children, drag_target, drop_target))
                    return;

                // update the parent id

                drag_target[this.pidf] = drop_target[this.idf];

                // do the same to the original item

                var index = this._findOriginalItemIndex(drag_target[this.idf]);

                if (index > -1) {
                    var q = this.original_items[index];
                    q[this.pidf] = drop_target[this.idf];

                    // TBD: order not preserved
                }

                $(e.currentTarget).after(x.element);

                // move the children

                var q = $(e.currentTarget).next();

                for (i = 0; i < children.length; i++) {

                    q = q.after(children[i].element);
                    q = q.next();

                    //$(e.currentTarget).next().next().before(children[i].element);
                }

                var items = this.toArrayDataOnly();

                var u = this._renderRow(drop_target, items);
                $(e.currentTarget).replaceWith(u);
                u.show();

                // we could be dragging into a closed node or an open node

                if (drop_target.expanded)
                    self.expand(drop_target[self.idf]);
                else
                    self.collapse(drop_target[self.idf]);

                this._applyCSS();
            },

            _stopListening: function () {
                this.$el.off();
            },

            _renderRow: function (o, items) {

                var s = this.settings;

                var row = $("<tr>", { 'class': 'mj-row' });

                if (s.dragdrop)
                    row.attr("draggable", "true");

                var data_clone = mjcore.clone(o);

                row.data("d", data_clone);        // associate data with the row

                var cell = $("<td>", { class: 'mj-cell' });

                if (this.hasChildren(o, items)) {

                    // if the item has child nodes, even if the items array is empty create an expander

                    var e = $("<div>", { 'class': 'mj-expander' });

                    if (o.expanded)
                        e.addClass("mj-open");                    
                    else
                        e.addClass("mj-closed");                    

                    cell.append(e);
                }

                // root nodes are always visible
                // is the the parent is expanded the child must be visible

                var p = this.getParent(o, items);

                if (o[this.pidf] == null || o.expanded || (p && p.expanded))
                    row.show();
                else
                    row.hide();

                // make the content: checkbox, image, text

                var c = $("<div>", { 'class': 'mj-content' });

                if (o.disabled)
                    c.addClass("mj-disabled");

                // cant be selected and disabled

                if (o.selected && !o.disabled)
                    c.addClass("selected");

                if (s.show_checkboxes) {

                    var checked = "";

                    switch (o.checked) {
                        case 1: checked = " checked"; break;
                        case 2: checked = " half-ticked"; break;
                    }

                    c.append("<div class='mj-checkbox-box" + checked + "'><div class='mj-tick'></div></div>");
                }

                // add the image

                if (o.image)
                    c.append("<img class='mj-image ' src='" + o.image + "' />");     

                var x = s.columns[0];
                var text;

                if (s.cellRender)
                    text = s.cellRender(o, x, 0);                
                else
                    text = o[x.data_field];                

                if (s.wrap_text)
                    c.append("<div class='mj-text' title='" + x.data_field + "'>" + text + "</div>");
                else
                    c.append("<div class='mj-text mj-nowrap' title='" + x.data_field + "'>" + text + "</div>");

                // associate data with mj-content as well

                c.data("d", data_clone);

                cell.append(c);

                row.append(cell);

                // add the remaining columns

                for (var i = 1, len = s.columns.length; i < len; i++) {
                    x = s.columns[i];

                    var str = "";

                    if (s.cellRender)
                        str = s.cellRender(o, x, i);
                    else
                        str = o[x.data_field];

                    cell = $("<td>", { class: "mj-cell", html: str });

                    row.append(cell);
                }

                return row;
            },

            _redraw: function (t, items) {

                var self = this;

                if (!items)
                    return;

                // create the top level nodes

                for (var i = 0; i < items.length; i++) {

                    var o = items[i];

                    var r = self._renderRow(o, items);

                    t.append(r);
                }
            },

            _render: function () {

                // called once

                var self = this;
                var s = this.settings;

                var a = $("<div>", { 'class': 'mj-widget mj-treegrid mj-noselect' });

                var t = $("<table>", { 'class': 'mj-table mj-root' });

                if (s.dragdrop)
                    a.attr("draggable", "true");

                this._redraw(t, s.items);

                a.html(t);

                this.$el.html(a);

                this._applyCSS();

                //this.$el.find(".mj-treegrid").css({ width: s.width, height: s.height });

                // save references to original items for filtering

                this.original_items = [];

                var rows = this.$el.find(".mj-row");

                $.each(rows, function (index, e) {

                    var d = $(e).data("d");
                    self.original_items.push(d);
                });

                return this;
            },

            _applyCSS: function () {

                var self = this;
                var s = this.settings;

                // do padding

                this._removeExpanders();

                var items = this.toArray();

                $.each(items, function (index, o) {

                    var level = self.getLevel(o.data, items);

                    var indent = level * self.settings.sublist_indent + 2;

                    $(o.element).find(".mj-cell").first().css({ "padding-left": indent });
                });

                
                this._setColumnWidths();

                if (s.show_borders)
                    this.$el.find(".mj-cell").css({ border: "1px solid #" + s.border_color });
                else
                    this.$el.find(".mj-cell").css({ border: "1px solid transparent" });
            },

            _removeExpanders: function () {

                var self = this;

                // remove expander and set data.expanded to false for any nodes which dont have children

                var items = this.toArrayDataOnly();

                $.each(items, function (index, o) {

                    if (!self.hasChildren(o, items)) {

                        var e = self.getItem(o.id);

                        if (e) {

                            e.element.find(".mj-expander").remove();
                            e.data.expanded = false;
                        }
                    }
                });
            },

            _setColumnWidths: function () {

                var self = this;

                $.each(this.settings.columns, function (index, c) {

                    var e = self.$el.find(".mj-cell:nth-child(" + (index + 1) + ")");

                    var style = {};

                    if (c.width) {
                        style.width = c.width;
                        style["max-width"] = c.width;
                    }

                    if (c.text_align)
                        style["text-align"] = c.text_align;

                    e.css(style);
                });
            },

            _treeRecurseUp: function (o, items, callback) {

                // for filtering

                if (!o || !callback)
                    return;

                for (var i = 0, len = items.length; i < len; i++) {

                    var x = items[i];

                    if (x[this.idf] && x[this.idf] == o[this.pidf]) {

                        // x is the parent of o

                        callback(x);
                        this._treeRecurseUp(x, items, callback);
                        break;
                    }
                }
            },

            _treeRecurseDown: function (o, items, callback) {

                // for filtering

                // go through the array of items
                // if any item in a child of o execute the callback

                if (!o || !callback)
                    return;

                for (var i = 0, len = items.length; i < len; i++) {

                    var x = items[i];

                    if (o[this.idf] && o[this.idf] == x[this.pidf]) {

                        // x is a child of o

                        callback(x);
                        this._treeRecurseDown(x, items, callback);
                    }
                }
            },

            _findOriginalItemIndex: function(id)
            {
                var index = -1;

                for (var i = 0, len = this.original_items.length; i < len; i++) {

                    var q = this.original_items[i];

                    if (q[this.idf] == id) {
                        index = i;
                        break;
                    }
                }

                return index;
            },

            //----------------------------------------------------------------------------
            // public interface
            //----------------------------------------------------------------------------           

            getParent: function (o, items) {

                if (!o)
                    return null;

                if (items == undefined)
                    items = this.toArray();

                for (var i = 0, len = items.length; i < len; i++) {

                    var x = items[i];

                    if (x.data != null && x.data != undefined)
                        x = items[i].data;

                    if (o[this.pidf] === x[this.idf])
                        return x;
                }

                return null;
            },

            getLevel: function (o, items) {

                var level = 0;

                if (items == undefined)
                    items = this.toArray();

                while (o) {
                    o = this.getParent(o, items);

                    if (o)
                        level++;
                }

                return level;
            },

            hasChildren: function (o, items) {

                if (mjcore.isEmpty(items))
                    items = this.toArrayDataOnly();
                    
                for (var i = 0, len = items.length; i < len; i++) {

                    var x = items[i];

                    if (x[this.pidf] == o[this.idf])
                        return true;
                }


                return false;
            },

            getChildren: function (id) {

                // get all children of a node
                // all levels

                var self = this;
                var rows = this.toArray();

                // recurse

                function _getChildren(rows, id) {

                    var children = [];

                    $.each(rows, function (index, r) {

                        var o = r.data;

                        if (o[self.pidf] === id) {
                            children.push(r);

                            var arr = _getChildren(rows, o[self.idf]);

                            $.each(arr, function (index, a) { children.push(a); });
                        }
                    });

                    return children;
                }

                return _getChildren(rows, id);
            },

            toArray: function () {

                // returns array of {element, data}

                var rows = this.$el.find(".mj-row");

                var arr = [];

                $.each(rows, function (index, e) { arr.push({ element: e, data: $(e).data("d") }); });

                return arr;
            },

            toArrayDataOnly: function () {

                // returns array of data items

                var rows = this.$el.find(".mj-row");

                var arr = [];

                $.each(rows, function (index, e) { arr.push($(e).data("d")); });

                return arr;
            },

            getItem: function (id) {

                // return {element, data}
                // can return more than 1 element

                var e = this._getRow(id);

                if (!e)
                    return null;

                return { element: e, data: e.data("d") };
            },

            _getRow: function (id) {

                // can return more than 1 element
                // returns row element

                var self = this;

                if (mjcore.isEmpty(id))
                    return null;
               
                var list = this.$el.find(".mj-row");

                var filtered = list.filter(function (index) { return $(this).data("d")[self.idf] == id; });

                if (filtered.length == 0)
                    return null;

                return filtered;
            },

            clear: function () {
                // empty the data and list

                this.settings.items = [];

                var e = this.$el.find(".mj-root");

                e.empty();
            },

            search: function (search_function) {

                // use user supplied function which returns true or false to test each object
                // returns an array of items

                if (!search_function)
                    return [];

                var list = this.$el.find(".mj-row");

                return list.filter(function (index) {

                    var o = $(this).data("d");

                    return search_function(o);
                });
            },

            //------------------------------------------------------------------------------------------------
            // enable, disable functions

            enableAll: function () {

                this.$el.find(".mj-row").removeClass("mj-disabled");

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").disabled = false; });
            },

            disableAll: function () {

                this.$el.find(".mj-row").addClass("mj-disabled");

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").disabled = true; });
            },

            enable: function (id) {

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.enableItem: node " + id + " not found");
                    return;
                }

                o.data.disabled = false;
                o.element.removeClass("mj-disabled");

                var children = this.getChildren(id);

                $.each(children, function (index, o) {
                    o.data.disabled = false;
                    $(o.element).removeClass("mj-disabled");
                });
            },

            disable: function (id) {

                var self = this;

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.disableItem: node " + id + " not found");
                    return;
                }

                o.data.disabled = true;
                o.element.addClass("mj-disabled");

                var children = this.getChildren(id);

                $.each(children, function (index, o) {
                    o.data.disabled = true;
                    $(o.element).addClass("mj-disabled");
                });
            },

            //---------------------------------------------------------------------------------------------------------
            // checkbox functions

            toggle: function (id) {

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.toggle: node " + id + " not found");
                    return;
                }

                if (this.settings.show_checkboxes) {

                    if (o.data.checked == 1)
                        this.uncheck(id);
                    else
                        this.check(id);
                }
                else {

                    if (o.data.selected)
                        this.deselect(id);
                    else
                        this.select(id);
                }
            },

            checkAll: function () {

                if (!this.settings.show_checkboxes)
                    return;

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").checked = 1; });

                this.$el.find(".mj-checkbox-box").addClass("checked").removeClass("half-ticked");
            },

            uncheckAll: function () {

                if (!this.settings.show_checkboxes)
                    return;

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").checked = 0; });

                this.$el.find(".mj-checkbox-box").removeClass("checked").removeClass("half-ticked");
            },

            check: function (id, check_parents) {

                var self = this;
                var s = this.settings;

                if (!s.show_checkboxes)
                    return;

                function checkParent(arr, o) {

                    for (var i = 0, len = arr.length; i < len; i++) {
                        var r = arr[i];

                        if (r.data[self.idf] === o.data[self.pidf]) {
                            r.data.checked = 1;
                            $(r.element).find(".mj-checkbox-box").addClass("checked").removeClass("half-ticked");

                            if (r.data[self.pidf] == null)     // end of the line
                                return;

                            checkParent(arr, r);
                            break;
                        }
                    }
                }

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.check: node " + id + " not found");
                    return;
                }

                // check all sublist checkboxes 

                var e = $(o.element);
                e.find(".mj-checkbox-box").addClass("checked").removeClass("half-ticked");
                o.data.checked = 1;

                var arr;

                if (s.recursive) {

                    // check the children

                    arr = this.getChildren(id);

                    $.each(arr, function (index, a) {

                        a.data.checked = 1;
                        e = $(a.element);
                        e.find(".mj-checkbox-box").addClass("checked").removeClass("half-ticked");
                    });

                    if (check_parents == true || check_parents == undefined) {

                        // check all parent checkboxes 


                        arr = this.toArray();

                        checkParent(arr, o);
                    }
                }
            },

            uncheck: function (id) {

                if (!this.settings.show_checkboxes)
                    return;

                var self = this;

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.uncheck: node " + id + " not found");
                    return;
                }

                var e = $(o.element);
                e.find(".mj-checkbox-box").removeClass("checked").removeClass("half-ticked");
                o.data.checked = 0;

                // deselect children of this node
                // always do this, ignore settings.recursive, doesnt make sense to not deselect children

                // check the children of this node

                var arr = this.getChildren(id);

                $.each(arr, function (index, a) {

                    a.data.checked = 0;
                    e = $(a.element);
                    e.find(".mj-checkbox-box").removeClass("checked").removeClass("half-ticked");
                });
            },

            checkAt: function (n) {

                var arr = this.$el.find(".mj-row");

                if (n < 0 || n >= arr.length)
                    return;

                var e = arr[n];

                if (e)
                    this.check($(e).data("d")[this.idf]);
            },

            uncheckAt: function (n) {

                var arr = this.$el.find(".mj-row");

                if (n < 0 || n >= arr.length)
                    return;

                var e = arr[n];

                if (e)
                    this.uncheck($(e).data("d")[this.idf]);
            },

            getChecked: function () {

                // return array of checked items

                var arr = [];

                $.each(this.$el.find(".mj-row"), function (index, e) {

                    var d = $(e).data("d");

                    if (d.checked == 1)
                        arr.push({ element: e, data: d, index: index });
                });

                return arr;
            },

            halfTick: function (id) {

                if (!this.settings.show_checkboxes)
                    return;

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.halfTick: node " + id + " not found");
                    return;
                }

                this.uncheck(id);       // uncheck child nodes

                o.data.checked = 2;
                $(o.element).find(".mj-checkbox-box").removeClass("checked").addClass("half-ticked");
            },

            halfTickAt: function (n) {

                var list = this.$el.find(".mj-row");

                if (n < 0 || n >= list.length)
                    return;

                var o = $(list[n]).data("d");

                if (o)
                    this.halfTick(o[this.idf]);
            },

            halfTickAll: function () {

                if (!this.settings.show_checkboxes)
                    return;

                // dont call halfTick for every node, too slow

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").checked = 2; });

                this.$el.find(".mj-checkbox-box").removeClass("checked").addClass("half-ticked");
            },

            deselectHalfTicked: function () {

                if (!this.settings.show_checkboxes)
                    return;

                // dont call halfTick for every node, too slow
                // deselect all nodes which are half ticked

                $.each(this.$el.find(".mj-row"), function (index, e) {

                    var o = $(e).data("d");

                    if (o.checked == 2)
                        o.checked = 0;
                });

                this.$el.find(".mj-checkbox-box.half-ticked").removeClass("half-ticked");
            },

            //--------------------------------------------------------------------------
            // select functions

            select: function (id) {

                if (this.settings.show_checkboxes)
                    return;

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.select: node " + id + " not found");
                    return;
                }

                if (!this.settings.multi_select)
                    this.deselectAll();

                o.data.selected = true;
                o.element.find(".mj-content").addClass("selected");
            },

            deselect: function (id) {

                if (this.settings.show_checkboxes)
                    return;

                var o = this.getItem(id);

                if (!o) {
                    mjcore.mjError("mjTreeGrid.deselect: node " + id + " not found");
                    return;
                }
                
                o.data.selected = false;
                o.element.find(".mj-content").removeClass("selected");
            },

            getSelected: function () {

                var arr = [];

                if (this.settings.show_checkboxes)
                    return arr;

                $.each(this.$el.find(".mj-row"), function (index, e) {

                    var o = $(e).data("d");

                    if (o.selected)
                        arr.push({ element: e, data: o, index: index });
                });

                return arr;
            },

            selectAll: function () {

                if (this.settings.show_checkboxes)
                    return;

                // dont call select for every node, too slow

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").selected = true; });

                this.$el.find(".mj-content").addClass("selected");
            },

            deselectAll: function () {

                if (this.settings.show_checkboxes)
                    return;

                // dont call deselect for every node, too slow

                $.each(this.$el.find(".mj-row"), function (index, e) { $(e).data("d").selected = false; });

                this.$el.find(".mj-content").removeClass("selected");
            },

            selectAt: function (n) {

                var list = this.$el.find(".mj-content");

                if (n < 0 || n >= list.length)
                    return;

                var o = $(list[n]).data("d");

                if (o)
                    this.select(o[this.idf]);
            },

            deselectAt: function (n) {

                var list = this.$el.find(".mj-content");

                if (n < 0 || n >= list.length)
                    return;

                var o = $(list[n]).data("d");

                if (o)
                    this.deselect(o[this.idf]);
            },

            //--------------------------------------------------------------------------------------------------------------

            flattenTree: function (tree) {

                var arr = [];

                $.each(tree, function (index, o) {

                    function _flattenTree(items) {

                        $.each(items, function (index, x) {

                            arr.push(x);

                            if (x.items)
                                _flattenTree(x.items);
                        });
                    }

                    arr.push(o);

                    if (o.items)
                        _flattenTree(o.items);
                });

                // remove the items property

                $.each(arr, function (index, o) { delete o.items; });

                return arr;
            },

            toTree: function (collection) {

                var self = this;

                if (collection == undefined)
                    collection = this.toArrayDataOnly();

                var tree = [];

                if (!collection || collection.length == 0)
                    return tree;

                // get top level nodes

                var arr = [];

                $.each(collection, function (index, o) {
                    arr.push(mjcore.clone(o));
                });

                collection = arr;

                $.each(collection, function (index, o) {

                    if (o[self.pidf] == null)
                        tree.push(o);
                });

                function _toTree(items, collection) {

                    if (!items)
                        return;

                    $.each(items, function (index, x) {

                        // find the children of this node

                        $.each(collection, function (index, o) {

                            if (x[self.idf] != null && x[self.idf] == o[self.pidf]) {

                                if (!x.items)
                                    x.items = [];

                                x.items.push(o);        // add item to a folder
                            }
                        });

                        _toTree(x.items, collection);         // go down the tree recursively
                    });
                }

                _toTree(tree, collection);

                return tree;
            },

            sort: function (callback) {

                var self = this;

                // local function

                function _sort(items, callback) {

                    if (callback) {

                        items.sort(function (a, b) { return callback(a, b); });
                    }
                    else {

                        var c = self.settings.columns[0].data_field;

                        // no callback function provided, compare text fields

                        items.sort(function (a, b) {

                            // get the name of the 1st column

                            if (a[c].toLowerCase() > b[c].toLowerCase())
                                return 1;

                            if (a[c].toLowerCase() < b[c].toLowerCase())
                                return -1;

                            return 0;
                        });
                    }

                    $.each(items, function (index, o) {

                        if (o.items)
                            _sort(o.items, callback);
                    });
                };

                var collection = this.toArrayDataOnly();

                var tree = this.toTree(collection);

                _sort(tree, callback);

                var arr = this.flattenTree(tree);                

                var e = this.$el.find(".mj-root ");

                e.empty();

                this._redraw(e, arr);

                this._applyCSS();
            },

            filter: function (val, comparison_callback) {

                if (!comparison_callback)
                    return;

                var items = this.original_items;

                var arr = [];

                if (!val || val == "") {

                    // no filter

                    for (var i = 0; i < items.length; i++)
                        arr.push(items[i]);                    
                }
                else {
                    for (var i = 0; i < items.length; i++) {

                        var o = items[i];

                        if (comparison_callback(o, val)) {

                            if (arr.indexOf(o) == -1)
                                arr.push(o);

                            this._treeRecurseDown(o, items, function (x) {

                                if (arr.indexOf(x) == -1)
                                    arr.push(x);
                            });

                            this._treeRecurseUp(o, items, function (x) {

                                if (arr.indexOf(x) == -1)
                                    arr.push(x);
                            });
                        }
                    }
                }

                var e = this.$el.find(".mj-root ");

                e.empty();

                var tree = this.toTree(arr);

                var arr = this.flattenTree(tree);

                this._redraw(e, arr);

                this._applyCSS();
            },

            getSiblings: function (id) {

                var self = this;

                // get siblings of an item including the item

                var siblings = [];

                var o = this.getItem(id);

                if (!o)
                    return siblings;

                var arr = this.toArray();

                for (var i = 0, len = arr.length; i < len; i++) {

                    var x = arr[i];

                    if (x.data[this.pidf] === o.data[this.pidf])
                        siblings.push(x);
                }

                return siblings;
            },

            getNextSibling: function(id)
            {
                var siblings = this.getSiblings(id);

                if (siblings.length == 0)
                    return null;

                for (var i = 0; i < siblings.length; i++)
                {
                    var o = siblings[i];

                    if (o.data[this.idf] == id)      // found itself in the list of siblings
                        break;                    
                }

                if (i < (siblings.length-1))      // if there are more siblings in the list return the next one                                    
                    return siblings[i+1];

                return null;        // no next sibling
            },

            //----------------------------------------------------------------------------------------------------
            // add, insert, update, remove

            insert: function(id, data)
            {
                this.addBefore(id, data);       // same as addBefore
            },

            addBefore: function (id, data) {

                // create a sibling node

                if (id == null || data == null)
                    return;

                var o = this.getItem(id);

                if (!o)
                    return null;                             

                var index = this._findOriginalItemIndex(id);

                data = mjcore.clone(data);     // clone the data
                this._validateItem(data);

                if (!this.settings.show_checkboxes && !this.settings.multi_select)        // cant have 2 rows selected
                    this.deselectAll();             

                // update the parent id

                data[this.pidf] = o.data[this.pidf];

                var items = this.toArrayDataOnly();

                var x = this._renderRow(data, items);

                o.element.before(x);

                if (index > -1)
                    this.original_items.splice(index, 0, x.data("d"));
                else
                    mjcore.mjError("mjTreeGrid.addBefore: item not found in original_items");

                // give it the same visibility as the selected item

                if (o.element.is(":visible"))
                    x.show();

                this._applyCSS();
            },

            addAfter: function (id, data) {

                var self = this;

                // create a sibling node

                if (id == null || data == null)
                    return;

                var o = this.getItem(id);

                if (!o)
                    return null;

                // update the parent id

                data[this.pidf] = o.data[this.pidf];

                // find the last immediate child

                var rows = this.$el.find(".mj-row");

                var last_child_row = null;

                $.each(rows, function (index, e) {

                    var d = $(e).data("d");
                    
                    if (d[self.pidf] == o.data[self.idf])
                        last_child_row = e; 
                });

                if (last_child_row)
                    o = { element: $(last_child_row), data: $(last_child_row).data("d") };

                var index = this._findOriginalItemIndex(id);

                data = mjcore.clone(data);     // clone the data
                this._validateItem(data);                

                if (!this.settings.show_checkboxes && !this.settings.multi_select)        // cant have 2 rows selected
                    this.deselectAll();

                var items = this.toArrayDataOnly();

                var x = this._renderRow(data, items);

                o.element.after(x);

                var d = x.data("d");

                if (index > -1)
                    this.original_items.splice(index + 1, 0, d);
                else
                    mjcore.mjError("mjTreeGrid.addAfter: item not found in original items");

                // give it the same visibility as the selected item

                if (o.element.is(":visible"))
                    x.show();

                this._applyCSS();
            },

            addRootNode: function (data) {

                if (!data)
                    return null;                

                data = mjcore.clone(data);     // clone the data
                this._validateItem(data);

                if (!this.settings.show_checkboxes && !this.settings.multi_select)        // cant have 2 rows selected
                    this.deselectAll();

                data[this.pidf] = null;     // its a root node with no parent

                // add new root node at the end of the list

                var items = this.toArrayDataOnly();

                var x = this._renderRow(data, items);

                var e = this.$el.find(".mj-root");

                e.append(x);

                this.original_items.push(data);
            },

            addChild: function (id, data) {

                if (!data)
                    return;

                var data = mjcore.clone(data);     // clone the data
                this._validateItem(data);

                // if id is null just add a root node

                if (id == null) {
                    this.addRootNode(data);
                    return;
                }

                // create a child node

                var o = this.getItem(id);

                if (!o)
                    return;

                var index = this._findOriginalItemIndex(id);

                if (!this.settings.show_checkboxes && !this.settings.multi_select)        // cant have 2 rows selected
                    this.deselectAll();

                var items = this.toArrayDataOnly();

                data[this.pidf] = o.data[this.idf];

                var r = this._renderRow(data, items);

                o.element.after(r);

                if (index > -1)
                    this.original_items.splice(index + 1, 0, r.data("d"));
                else
                    mjcore.mjError("mjTreeGrid.addChild: item not found in original_items");

                var q = o.element.next();

                var items = this.toArrayDataOnly();

                if (this.hasChildren(o.data, items) && o.data.expanded)
                    q.show();

                // need to rerender the row we are adding a child into to get the expander
                
                var u = this._renderRow(o.data, items);
                o.element.replaceWith(u);
                u.show();

                this._applyCSS();
            },

            update: function (id, data) {

                // the data will completely replace the previous data

                if (!data)
                    return;

                var o = this.getItem(id);

                if (!o)
                    return;

                // give the data the same id, pid as the original

                //var x = $(e).data("d");
                var x = o.data;

                var index = this._findOriginalItemIndex(id);

                var data = mjcore.clone(data);     // clone the data
                this._validateItem(data);

                data[this.idf] = x[this.idf];
                data[this.pidf] = x[this.pidf];

                var visible = o.element.is(":visible");

                if (!this.settings.show_checkboxes && !this.settings.multi_select)        // cant have 2 rows selected
                    this.deselectAll();

                var items = this.toArrayDataOnly();

                var r = this._renderRow(data, items);
                o.element.replaceWith(r);
                                
                if (index > -1)
                    this.original_items[index] = r.data("d");
                else
                    mjcore.mjError("mjTreeGrid.update: item not found in original items");

                if (visible) {

                    // if the item was originally visible show it

                    var e = this.getItem(id);
                    e.element.show();

                    // you will need to re-create any event handlers on the control after doing this

                    if (data.expanded)
                        this.expand(id);
                    else
                        this.collapse(id);
                }
                    
                this._applyCSS();
            },

            remove: function (id) {

                var self = this;

                // remove a node and all its children

                var o = this.getItem(id);

                if (!o)
                    return;

                var index = this._findOriginalItemIndex(id);

                if (index > -1)
                    this.original_items.splice(index, 1);
                else
                    mjcore.mjError("mjTreeGrid.remove: item not found in original_items");

                $(o.element).data("d", null);
                $(o.element).children().off();
                $(o.element).remove();

                var arr = this.getChildren(id);

                $.each(arr, function (index, x) {

                    index = self._findOriginalItemIndex($(x.element).data("d").id);

                    if (index > -1)
                        self.original_items.splice(index, 1);

                    $(x.element).data("d", null);
                    $(x.element).children().off();
                    $(x.element).remove();
                });

                this._applyCSS();
            },

            //------------------------------------------------------------------------------------

            expand: function (id) {

                var self = this;

                var o = this.getItem(id);

                if (!o)
                    return;

                var expander = o.element.find(".mj-expander");

                if (!expander)
                    return;

                var items = this.getChildren(id);

                // show immediate children

                $.each(items, function (index, x) {

                    if (x.data[self.pidf] == id)
                        $(x.element).show();

                    // if the child is expanded show it, recursive

                    if (x.data.expanded)
                        self.expand(x.data[self.idf])
                });

                o.data.expanded = true;

                expander.removeClass("mj-closed").addClass("mj-open");
            },

            collapse: function (id) {

                var o = this.getItem(id);

                if (!o)
                    return;

                var expander = $(o.element).find(".mj-expander");

                if (!expander)
                    return;

                // hide all children
                // dont collapse children just hide them        

                var items = this.getChildren(id);

                $.each(items, function (index, x) { $(x.element).hide(); });

                o.data.expanded = false;

                expander.removeClass("mj-open").addClass("mj-closed");
            },

            expandAll: function () {

                var self = this;

                $.each(this.$el.find(".mj-row"), function (index, e) { var id = $(e).data("d")[self.idf]; self.expand(id); });
            },

            collapseAll: function () {

                var self = this;

                $.each(this.$el.find(".mj-row"), function (index, e) { var id = $(e).data("d")[self.idf]; self.collapse(id); });
            },

            getExpanded: function () {

                var arr = [];

                $.each(this.$el.find(".mj-row .mj-expander.mj-open"), function (index, e) {

                    var p = $(e).closest(".mj-row");
                    var o = p.data("d");
                    o.expanded = true;

                    arr.push({ element: p, data: o });
                });

                return arr;
            },

            //--------------------------------------------------------------------
            
            /*
            saveState: function () {

                // save the state of the list

                var self = this;

                this.original_data = [];

                var items = this.toArrayDataOnly();

                $.each(items, function (index, o) {
                    self.original_data.push({ checked: o.checked, selected: o.selected });
                });
            },

            hasChanged: function () {

                var items = this.toArrayDataOnly();

                var len1 = items.length;
                var len2 = this.original_data.length;

                if (len1 != len2)       // rows were added or deleted
                    return true;

                for (var i = 0; i < len1; i++) {

                    var a = items[i];
                    var b = this.original_data[i];

                    // if new state is undefined dont count it as a change

                    if (a.checked != b.checked || a.selected != b.selected)
                        return true;
                }

                return false;
            },
            */
            
            close: function () {

                // dont clear the data
                // important to turn off events

                this._stopListening();
                this.$el.data(this, 'mj-treegrid-data', null);
                this.$el.html("");
            },

            scrollTo: function (id, animate) {

                var o = this.getItem(id);

                if (!o)
                    return;

                // need to use position rather than offset

                var pos = $(o.element).position().top;

                if (animate)
                    this.$el.find(".mj-treegrid").animate({ scrollTop: pos }, 300);
                else
                    this.$el.find(".mj-treegrid").scrollTop(pos);
            }
        };

        $.fn.mjTreeGrid = function (options) {

            // options is empty or an object
            // within a plugin use this not $(this)
            // check that element exists using this.length

            if (!this.length) {

                mjcore.mjError("mjTreeGrid: the html element to attach to '" + this.selector + "' does not exist");

                return null;
            }

            if (mjTreeGrid[options]) {

                // called a function in mjTreeGrid, if no data attached object has not been created yet

                var q = $(this).data('mj-treegrid-data');

                if (q)
                    return q[options].apply(q, Array.prototype.slice.call(arguments, 1));
            }
            else if (!options || typeof options === 'object') {

                // return is for chainability, dont have to return anything
                // if the selector was multiply defined you would be creating plugin for each selector

                return this.each(function () {

                    var treegrid = Object.create(mjTreeGrid);
                    
                    treegrid.init(options, this);

                    $.data(this, 'mj-treegrid-data', treegrid);
                });

                // to call a function:

                // $('#my-dom-element').mjTreeGrid("check", 99);

                // another way to call a function:

                //var myTreeview = $('#my-dom-element').data('mj-treegrid-data');
                //myTreeview.check(id);
            }
            else {

                // method does not exist

                mjcore.mjError("Method '" + options + "' does not exist on mjTreeGrid");
            }
        };
    })(jQuery);

});